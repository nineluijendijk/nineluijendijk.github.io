[["index.html", "Portfolio 1 Prerequisites", " Portfolio Nine Luijendijk 2022-12-22 1 Prerequisites Work in progress "],["resume.html", "2 Curriculum Vitae Nine Luijendijk 2.1 Contact 2.2 Education 2.3 Experience 2.4 Skills 2.5 Languages", " 2 Curriculum Vitae Nine Luijendijk 2.1 Contact E-mail: nineluijendijk@gmail.com Phone: +31617210407 LinkedIn: https://www.linkedin.com/in/nine-luijendijk-75a973257/ 2.2 Education Hogeschool Utrecht Bachelor of Science - BS, Life Sciences, Sep. 2020 - Aug. 2024 Specialized in Data Sciences for Biology 2.3 Experience Zeeman textielSupers - Leusden Sales Associate, Nov. 2021 - Present StudyWorks BV - Leusden Tutor, Jan. 2020 - Sep. 2021 Tutored high school students in English, math and chemistry. 2.4 Skills R programming language Bash command language 2.5 Languages Dutch English "],["guerillaframework.html", "3 Guerilla Analytics framework", " 3 Guerilla Analytics framework To keep my data manageable I use the Guerilla Analytics framework. This means I make sure every project has its own folder, every folder that needs it has a README and no raw data file is altered. The way I manage my data is visible in the tree below: dir_tree(&quot;/Users/nineluijendijk/Desktop/daur2&quot;) knitr::include_graphics(here(&quot;data/screenshot_dirtree.png&quot;)) "],["datanalysis.html", "4 Analyzing data from an experiment 4.1 Open the file in R and inspect the data. 4.2 Fixing the character/double issue 4.3 Think about how you would analyze this experiment to learn whether there is indeed an effect of different concentrations on offspring count and whether the different compounds have a different curve (IC50). Write down you analysis as a step-wise plan. 4.4 Normalize the data for the controlNegative in such a way that the mean value for controlNegative is exactly equal to 1 and that all other values are expressed as a fraction thereof. Rerun your graphs with the normalized data.", " 4 Analyzing data from an experiment In this experiment, the number of offspring of adult C. elegans was counted after exposing the nematodes to different substances in multiple concentrations. The data was supplied by J. Louter of the INT/ILC. 4.1 Open the file in R and inspect the data. celegans_data &lt;- read_excel(&quot;/Users/nineluijendijk/Downloads/CE.LIQ.FLOW.062_Tidydata.xlsx&quot;) Expected data types would be double/integer for RawData (number of offspring), character for compName (name of the compound) and double for compConcentration (concentration of the compound). The actual data types of the columns are double for RawData, character for compName and character for compConcentration. The data type for compConcentration has not been correctly assigned which will cause the following issue if it’s not changed: #Create a scatter plot plot_chr &lt;- ggplot(data = celegans_data, aes(x = compConcentration, y = RawData))+ geom_point(aes(color = compName, shape = expType), size = 1)+ rotate_axis_labels(&quot;x&quot;, 90)+ labs(x = &quot;Concentration&quot;, y = &quot;Number of offspring&quot;, title = &quot;Number of C. elegans offspring under\\na number of circumstances, alphabetical&quot;, shape = &quot;Type&quot;, color = &quot;Compound&quot;)+ scale_colour_manual(values = c(&quot;red&quot;, &quot;darkgoldenrod1&quot;, &quot;green&quot;, &quot;royalblue3&quot;, &quot;violet&quot;))+ theme(legend.key.size = unit(0.75,&quot;line&quot;), legend.text = element_text(size = 8)) plot_chr (#fig:alphabetical_plot)Number of C. elegans offspring under a number of circumstances where the x-axis is ordered alphabetically The x-axis labels are ordered alphabetically because the data type of the compConcentration is character instead of double. R probably read it this way because Excel adds an E to showcase exponential values. 4.2 Fixing the character/double issue After changing the data type from character to double and adding jitter to the plot it looks as follows: #Change data type from chr to dbl celegans_data$compConcentration &lt;- as.double(celegans_data$compConcentration) #Create a scatter plot for the concentration in nM celegans_data_nM &lt;- celegans_data %&gt;% filter(compUnit == &quot;nM&quot;) plot_nM &lt;- ggplot(data = celegans_data_nM, aes(x = log10(compConcentration), y = RawData))+ geom_jitter(aes(color = compName, #add jitter shape = expType), width = 0.5, height = 0.2)+ labs(x = &quot;log10 concentration (nM)&quot;, y = &quot;Number of offspring&quot;)+ coord_cartesian(ylim = c(0, 120))+ scale_shape_manual(values = 3)+ scale_colour_manual(values = c(&quot;red&quot;, &quot;darkgoldenrod1&quot;, &quot;royalblue3&quot;))+ theme(legend.position = &quot;none&quot;) #Create a scatter plot for the concentration in pct celegans_data_pct &lt;- celegans_data %&gt;% filter(compUnit == &quot;pct&quot;) plot_pct &lt;- ggplot(data = celegans_data_pct, aes(x = expType, y = RawData))+ geom_jitter(aes(color = compName, #add jitter shape = expType), size = 1.3, width = 0.1, height = 0.075)+ xlab(&quot;Type&quot;)+ coord_cartesian(ylim = c(23.7, 121))+ scale_colour_manual(values = c(&quot;green&quot;, &quot;violet&quot;))+ theme(legend.position = &quot;none&quot;, axis.text.x=element_text(vjust=0.5, hjust=0.5, size = 8.75), axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.title.y = element_blank())+ #remove any y-axis labeling rotate_axis_labels(&quot;x&quot;, 90) #obtain legend legend &lt;- get_legend(plot_chr) #combine figures and legend for readability ggdraw(plot_grid(plot_grid(plot_nM, plot_pct), plot_grid(NULL, legend, ncol = 3), rel_widths = c(1, 0.35)))+ plot_annotation(&quot;Number of C. elegans offspring under\\na number of circumstances&quot;) The positive control for this experiment is ethanol. The negative control for this experiment is S-medium. 4.3 Think about how you would analyze this experiment to learn whether there is indeed an effect of different concentrations on offspring count and whether the different compounds have a different curve (IC50). Write down you analysis as a step-wise plan. 4.4 Normalize the data for the controlNegative in such a way that the mean value for controlNegative is exactly equal to 1 and that all other values are expressed as a fraction thereof. Rerun your graphs with the normalized data. #Obtain the mean of the RawData (negativeControl) controlNeg &lt;- celegans_data %&gt;% filter(compName == &quot;S-medium&quot;) %&gt;% summarize(mean = mean(RawData, na.rm = TRUE)) #Use the mean to calculate fractions mutated &lt;- celegans_data %&gt;% filter(RawData &gt; 0) %&gt;% select(RawData, compName, compConcentration, expType) %&gt;% na.omit() %&gt;% mutate(normalized = RawData/controlNeg$mean) #Obtain the means of the other 2 control groups controlPos &lt;- mutated %&gt;% filter(expType == &quot;controlPositive&quot;) %&gt;% summarize(mean = mean(normalized, na.rm = TRUE)) controlVeh &lt;- mutated %&gt;% filter(expType == &quot;controlVehicleA&quot;) %&gt;% summarize(mean = mean(normalized, na.rm = TRUE)) mutated %&gt;% filter(compName == &quot;2,6-diisopropylnaphthalene&quot; | compName == &quot;decane&quot; | compName == &quot;naphthalene&quot;) %&gt;% ggplot(aes(x = log10(compConcentration), y = normalized))+ geom_jitter(aes(color = compName), width = 0.5, height = 0.1)+ scale_colour_manual(values = c(&quot;red&quot;, &quot;darkgoldenrod1&quot;, &quot;royalblue3&quot;))+ coord_cartesian(ylim = c(0, 1.5))+ labs(x = &quot;log10 concentration (nM)&quot;, y = &quot;Normalized number of offspring&quot;, title = &quot;Number of C. elegans offspring as a fraction\\nof the negative control group&quot;, color = &quot;Compound&quot;)+ geom_hline(yintercept = 1, color = &quot;violet&quot;)+ geom_hline(yintercept = controlPos$mean, color = &quot;green&quot;)+ geom_hline(yintercept = controlVeh$mean, color = &quot;green&quot;, linetype = &quot;longdash&quot;)+ guides(color = &quot;none&quot;)+ annotate(&quot;text&quot;, x = -3.8, y = 0.55, label = &quot;controlPositive&quot;, size = 2)+ annotate(&quot;text&quot;, x = -3.8, y = 0.95, label = &quot;controlNegative&quot;, size = 2)+ annotate(&quot;text&quot;, x = -3.8, y = 1.05, label = &quot;controlVehicleA&quot;, size = 2)+ facet_wrap(~ compName) This way it’s easier to read the graph. Everything below the pink line means less offspring than control C. elegans and everything above it means more. "],["primates.html", "5 Generating a phylogenetic tree in R 5.1 The plan 5.2 Preparatory research 5.3 Getting started 5.4 Generating the first tree 5.5 Different types of phylogenetic models", " 5 Generating a phylogenetic tree in R 5.1 The plan In 2 years’ time I want to be doing my master’s in Biology at Universiteit Leiden. I would like to specialize in Evolutionary Biology. Next semester I will be attending classes at Radboud Universiteit that are part of their minor Biology - Adaptive Organisms to get a head start on learning about evolutionary biology, both because it’s something I enjoy and to make the transition from life sciences to the master’s program easier I would like to learn more about the differences between multiple primates and generate a phylogenetic tree. Prior to me starting on the actual code for this phylogenetic tree, I had to look into the different types of trees and how to generate them. 5.2 Preparatory research I started by looking for R packages having to do with phylogenetic research. There were ample packages to help generate phylogenetic trees, but none of them seemed to have all the tools needed. Wanting to keep my research as reproducible as possible, my main priority was to keep every single part of the research in R, which is free and open source software (R Core Team 2014). To get an idea of how to get started, I read a couple of papers by researchers who’ve created phylogenetic trees. In these papers, most of the software used to generate the trees (and all the steps that come before) was not R (Pozzi et al. 2014); (Perelman et al. 2011). Some of the programs were point and click as well (Suchard et al. 2018); (Vaidya, Lohman, and Meier 2011), making the research less reproducible. After looking at some different R packages I decided {ape} (Paradis and Schliep 2019) was the best option, seeing as most packages for phylogenetic research are dependent on it (Jombart and Ahmed 2011). The first step in the analysis was to obtain the data from an online database. NCBI has their own command-line tool called NCBI Datasets (NCBI Staff 2022). The command-line tool was installed using Miniconda3 (Anaconda n.d.). The tool did work fine, but it wasn’t exactly what I was looking for. This was also when it was decided to perform the analysis on the mitochondrial genomes of the primates, instead of the nuclear genomes, due to computational limitations. 5.3 Getting started I ended up making a list of the species of interest, containing their GenBank (Benson et al. 2013) identifier, scientific name and their common name, and saving it in a text file called species.txt. This is the only part of the code that would need to be changed in case a species is to be added. To keep the code tidy the packages {tidyverse} (Wickham et al. 2019) and {here} (Müller n.d.) are used. {BiocManager} (Ramos and Morgan n.d.) was also used to install packages. 5.4 Generating the first tree 5.4.1 Obtaining FASTA sequences The file is read by R and filtered so that the comments (species’ names) are removed, and only the GenBank identifier remains. Then, using the package {rentrez} (Winter 2017), the FASTA sequences are obtained and stored in a vector. The FASTA sequences are then stored in a file so they can be used as input for the {ape} function read.FASTA, where the sequences will be converted to a vector of the class DNAbin. species &lt;-scan(file = here(&quot;data/species.txt&quot;), what = &quot;character&quot;, sep = &quot;\\n&quot;, comment.char = &quot;#&quot;) #import list of species to be analyzed fasta_seqs &lt;- entrez_fetch(db = &quot;nucleotide&quot;, id = species, rettype = &quot;fasta&quot;) #retrieve the fasta sequences of the mitochondrial genome of every species in the list write(fasta_seqs, file=&quot;temp&quot;) grep(&quot;^*$&quot;, readLines(&quot;temp&quot;), invert = TRUE, value = TRUE) %&gt;% write(file = here(&quot;data/sequences.fasta&quot;)) #remove empty lines so read.FASTA works file.remove(&quot;temp&quot;) dna &lt;- read.FASTA(here(&quot;data/sequences.fasta&quot;), type = &quot;DNA&quot;) #store the sequences in a vector of the type &quot;DNAbin&quot; 5.4.2 Performing multiple sequence alignment Now that the dna has been stored as DNAbin, a multiple sequence alignment will be performed using Clustal Omega 1.2.3 (Sievers et al. 2011). The aligned DNA is saved as a file, so the alignment only has to be performed once (since it takes a while). dna_aligned &lt;- clustalomega(dna, exec = here(&quot;clustalo&quot;)) #use Clustal Omega 1.2.3 to perform multiple sequence alignment saveRDS(dna_aligned, here(&quot;data/dna_aligned.RDS&quot;)) #save as file so the code only has to run once 5.4.3 Importing the aligned dna dna_aligned &lt;- readRDS(here(&quot;data/dna_aligned.RDS&quot;)) #import the aligned dna 5.4.4 Calculating the genetic distances between the sequences and drawing a tree The different dna sequences have been aligned and now the genetic distances between the sequences can be calculated using the Tamura and Nei 1993 model (TN93) (Tamura and Nei 1993). The distance matrix can be used as input to calculate the phylogenetic tree. The used algorithm is the BIONJ algorithm of Gascuel (Gascuel 1997). The generated tree is visualized as a cladogram using the package {ggtree} (Yu et al. 2017). It’s visualized as a cladogram for now to keep it easy to read while it’s being improved. dna_dist &lt;- dist.dna(dna_aligned, model = &quot;TN93&quot;) #calculate genetic distances and store in a vector of the type &quot;dist&quot; treebionj &lt;- bionj(dna_dist) #create a tree of the class &quot;phylo&quot; using the method neighbor joining ggtree(treebionj, branch.length = &quot;none&quot;, ladderize = F)+ #visualize the tree as a cladogram theme_tree()+ geom_tiplab(size = 6, as_ylab = T)+ labs(title = &quot;Unrooted neighbor joining cladogram of\\nmitochondrial genomes of 15 primates and the golden hamster&quot;) 5.5 Different types of phylogenetic models This first tree was generated using an improved neighbor joining model, which is just one of the four most commonly used (Yoshida and Nei 2016). Neighbor joining only looks at the distance between the sequences, but not at smaller details in the sequences (Yoshida and Nei 2016). A different method is maximum likelihood, where the likelihood of the different possible states of the tree is calculated, and the tree with the highest likelihood is generated (Dhar and Minin 2016). Two other popular methods are Bayesian inference and maximum parsimony (Dhar and Minin 2016); (Yoshida and Nei 2016). Since maximum likelihood is the preferred method in publications (Dhar and Minin 2016), that is the method I will be using. 5.5.1 Finding the best model The input for the {phangorn} modelTest function is an object of the class phyDat, so first the DNAbin object has to be converted: dna_phydat &lt;- as.phyDat(dna_aligned) #convert object to class phyDat The model test is ran and the model with the lowest Akaike information criterion (AIC, calculated by the {phangorn} function modelTest), making it the best model (Cavanaugh and Neath 2019), is saved, again so this only has to be performed once as it takes quite long. modeltest &lt;- modelTest(dna_phydat) #run the model test optmodel &lt;- modeltest$Model[modeltest$AIC==min(modeltest$AIC)] #find the model with the lowest AIC saveRDS(optmodel, here(&quot;data/optmodel&quot;)) #save as file so the code only has to run once optmodel &lt;- readRDS(here(&quot;data/optmodel&quot;)) #import the data again 5.5.2 Generating a maximum likelihood tree Using the neighbor joining tree, the aligned dna and the best model the maximum likelihood tree can be computed: mlparsed &lt;- pml(treebionj, dna_phydat) #generate the maximum likelihood tree The optim.pml function from {phangorn} is used to optimize the different model parameters. The model found using modelTest is not an option in the optim.pml function, so the closest option is used. optmodel &lt;- gsub(&quot;\\\\+.*&quot;,&quot;&quot;, optmodel) #change the string so the optim.pml function can read it mlparsedoptim &lt;- optim.pml(mlparsed, optNni=TRUE, model = optmodel) #optimize the tree 5.5.3 Visualizing the maximum likelihood cladogram treeml &lt;- ladderize(mlparsedoptim$tree) #ladderize the tree ggtree(treeml, branch.length = &quot;none&quot;, ladderize = F)+ #visualize the tree as a cladogram theme_tree()+ geom_tiplab(size = 6, as_ylab = T)+ labs(title = &quot;Unrooted maximum likelihood cladogram of\\nmitochondrial genomes of 15 primates and the golden hamster&quot;) 5.5.4 Rooting the tree The last step is to root the tree and clean up the tip labels (species names). It is important to root the tree, trees that aren’t rooted correctly may be misleading (Kinene et al. 2016). There are multiple ways to root a tree, I will be using an “outgroup”, a species that is genetically very different from the other species in the tree (Kinene et al. 2016). rootedml &lt;- root(treeml, outgroup = &quot;NC_013276.1 Mesocricetus auratus mitochondrion, complete genome&quot;, resolve.root = TRUE) #rooting the tree rootedml$tip.label &lt;- gsub(&quot;.*\\\\.[12]&quot;, &quot;&quot;, rootedml$tip.label) #clean up the labels rootedml$tip.label &lt;- gsub(&quot;(mitochondrion, | isolate | voucher).*genome&quot;, &quot;&quot;, rootedml$tip.label) #clean up the labels ggtree(rootedml, ladderize = F)+ #visualize the tree as a phylogenetic tree theme_tree()+ geom_tiplab(size = 2.5, as_ylab = F)+ xlim(0, 0.35)+ labs(title = &quot;Rooted maximum likelihood phylogenetic tree of\\nmitochondrial genomes of 15 primates and the golden hamster&quot;) The final tree is visualized as a phylogenetic tree instead of a cladogram, with different branch lengths describing the ancestry of the primates. The cladogram only showed how the different species are related (Pearson et al. 2013). Normally, more thought would go into selecting the best possible outgroup (Rota-Stabelli and Telford 2008). Since my goal was to learn how to generate a phylogenetic tree in R (within a reasonable timeframe) I chose an animal that I like and know is more genetically different from the primates than the primates between each other. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
